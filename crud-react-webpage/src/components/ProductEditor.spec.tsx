import ProductEditor from './ProductEditor';
import { Product } from '../models/Product';
import { Category } from '../models/Category';
import {ProductService} from '../services/ProductService';
import {product01, product02, oneProduct, twoCategories, threeCategories, waitMicroSeconds, myNever} from '../fixtures/fixtures';

import {fireEvent, render, RenderResult} from '@testing-library/react';
import React from 'react';

//to update snapshots
//npm run test -- -u

let productService : ProductService = new ProductService();

let mockServerGetProducts : jest.SpyInstance<Promise<Product[]>, []>;
let mockServerGetCategories : jest.SpyInstance<Promise<Category[]>, []>;
let mockServerUpdateProduct : jest.SpyInstance<Promise<any>, [productToUpdate: Product]>;
let mockServerAddProduct : jest.SpyInstance<Promise<any>, [productToSave: Product]>;

let mockSetNewList : jest.SpyInstance<void, [newProductList: Product[]]>;

let renderMocked:RenderResult;

/**
 * Mock server calls to GET list Categories, GET list products, POST create product and PUT update product
 * And mock call to Observer when calling setNewList, so it doesnt send list products to ProductList component
 */
beforeAll(function():void{
    mockServerGetProducts = jest.spyOn(productService,'serverGetProducts');
    mockServerGetCategories = jest.spyOn(productService,'serverGetCategories');
    mockServerUpdateProduct = jest.spyOn(productService,'serverUpdateProduct');
    mockServerAddProduct = jest.spyOn(productService,'serverAddProduct');

    mockServerGetProducts.mockResolvedValue(oneProduct);    
    mockServerUpdateProduct.mockResolvedValue({});
    mockServerAddProduct.mockResolvedValue({});

    //MOCK Observer    
    mockSetNewList = jest.spyOn(productService,'setNewList');
    mockSetNewList.mockResolvedValue(myNever);
});

/**
 * Mock GET list Categories to return 3 categories list
 * and render ProductEditor component 
 */
beforeEach(function():void{
    mockServerGetCategories.mockResolvedValue(threeCategories);
    renderMocked = render(<ProductEditor productService={productService} />);
});

/**
 * It checks rendered with previous snapshots
 * also checks if GET categories have been called
 */
it('check constructor three categories in the product editor', function():void{
    expect(mockServerGetCategories).toHaveBeenCalled();
    expect(renderMocked).toMatchSnapshot();//three categories snapshot
});

/**
 * It checks rendered with previous snapshots 2 categories list
 */
it('check constructor two categories in the product editor', function():void{ 
    mockServerGetCategories.mockResolvedValue(twoCategories);
    renderMocked = render(<ProductEditor productService={productService} />);
    expect(renderMocked).toMatchSnapshot();//two categories snapshot
});

/**
 * It checks if after clicking on edit button in ProductList component it sets the product to edit data in the form inputs
 */
it('check if click on edit in ProdutList triggers renderization of product data in ProductEditor s form', function():void{ 
    productService.addProductToEdit(product01);
    let inputName : any =  renderMocked.getByTestId('idName');
    let inputPrice : any =  renderMocked.getByTestId('idPrice');
    expect(inputName.value).toBe(product01.getName());
    if(inputPrice.value!=undefined)
        expect(parseFloat(inputPrice.value)).toBe(product01.getPrice());
    expect(renderMocked).toMatchSnapshot();//editing product01 snapshot
});

/**
 * It checks the sequence of events generated by clicking on edit in ProductList and after that clicking on save in ProductEditor,
 * expected calls in sequence : mockServerUpdateProduct, mockServerGetProducts and sends new list to ProductList
 */
it('check if click on edit in ProdutList and click on save in ProductEditor triggers mockServerUpdateProduct and mockServerGetProducts and sends new list to ProductList', async function():Promise<void>{ 
    productService.addProductToEdit(product02);
    let submitButton : HTMLElement =  renderMocked.getByTestId('idSubmitButton');
    fireEvent.click(submitButton);
    await waitMicroSeconds(50);
    expect(mockServerUpdateProduct).toHaveBeenCalled();
    expect(mockServerGetProducts).toHaveBeenCalled();
    expect(mockSetNewList).toHaveBeenCalled();
    expect(renderMocked).toMatchSnapshot();//editing product02 snapshot
});

/**
 * It checks the sequence of events generated by clicking on add in ProductEditor:
 * mockServerAddProduct, mockServerGetProducts and sends new list to ProductList
 */
it('check if click on add in ProductEditor triggers mockServerAddProduct and mockServerGetProducts and sends new list to ProductList', async function():Promise<void>{ 
    let inputName : HTMLElement =  renderMocked.getByTestId('idName');
    let inputPrice : HTMLElement =  renderMocked.getByTestId('idPrice');
    fireEvent.change(inputName,{target:{value:'name1'}});
    fireEvent.change(inputPrice,{target:{value:1.9}});
    let submitButton : HTMLElement =  renderMocked.getByTestId('idSubmitButton');
    fireEvent.click(submitButton);
    await waitMicroSeconds(50);
    expect(mockServerAddProduct).toHaveBeenCalled();
    expect(mockServerGetProducts).toHaveBeenCalled();
    expect(mockSetNewList).toHaveBeenCalled();
    expect(renderMocked).toMatchSnapshot();//adding product
});

